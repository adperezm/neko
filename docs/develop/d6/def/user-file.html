<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Neko: User File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Neko
   &#160;<span id="projectnumber">0.7.99</span>
   </div>
   <div id="projectbrief">A portable framework for high-order spectral element flow simulations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/def/user-file.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User File </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_pages_user_file"></a> The user file is a fortran file where the user can implement their own functions to extend the capabilities of the default Neko executable. The user file can be used for setting advanced initial/boundary conditions, source terms, I/O operations, and interactions with the Neko framework.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Compiling and running</h1>
<p>The user file is a regular Fortran <code>.f90</code> file that needs to be compiled with <code>makeneko</code>, located in the <code>bin</code> folder of your neko installation. To compile a user file <code>user.f90</code>, run:</p>
<div class="fragment"><div class="line">makeneko user.f90</div>
</div><!-- fragment --><p>If everything goes well, you should observe the following output:</p>
<div class="fragment"><div class="line">N E K O build tool, Version 0.7.99</div>
<div class="line">(build: 2024-02-13 on x86_64-pc-linux-gnu using gnu)</div>
<div class="line"> </div>
<div class="line">Building user NEKO ... done!</div>
</div><!-- fragment --><p>Compiling your user file with <code>makeneko</code> will create a <code>neko</code> executable, which you will need to execute with your case file as an argument. For example, if your case file is called <code>user.case</code>:</p>
<div class="fragment"><div class="line">./neko user.case</div>
</div><!-- fragment --><p>Or in parallel using MPI:</p>
<div class="fragment"><div class="line">mpirun -n 8 ./neko user.case</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
High-level structure</h1>
<p>The current high-level structure of the user file is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">module</span> user</div>
<div class="line">  <span class="keywordtype">use </span><a class="code" href="../../dd/d62/namespaceneko.html">neko</a></div>
<div class="line">  <span class="keywordtype">implicit none</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">contains</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Register user defined functions here (see user_intf.f90)</span></div>
<div class="line">  <span class="keyword">subroutine </span>user_setup(u)</div>
<div class="line">    <span class="keywordtype">type</span>(user_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">end subroutine </span>user_setup</div>
<div class="line"> </div>
<div class="line"><span class="keyword">end module </span>user</div>
<div class="ttc" id="anamespaceneko_html"><div class="ttname"><a href="../../dd/d62/namespaceneko.html">neko</a></div><div class="ttdoc">Master module.</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/d1f/neko_8f90_source.html#l00034">neko.f90:34</a></div></div>
</div><!-- fragment --><p>The user file implements the <code>user</code> module. The <code>user</code> modules contains a subroutine named <code>user_setup</code>, which we use to interface the internal procedures defined in <code><a class="el" href="../../d7/d30/user__intf_8f90.html">src/common/user_intf.f90</a></code> with the subroutines that you will implement in your user file. Each user subroutine should be implemented under the <code>contains</code> statement, below <code>user_setup</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The above code snippet is the most basic code structure for the user file. Compiling it and running it would be equivalent to running the "vanilla" neko executable <code>bin/neko</code> in your local neko installation folder.</dd></dl>
<h1><a class="anchor" id="autotoc_md21"></a>
Default user functions</h1>
<p>The following user functions, if defined in the user file, will always be executed, regardless of what is set in the case file:</p>
<ul>
<li><a href="../../#user-file_init-and-final">user_init_modules</a>: For initializing user variables and objects</li>
<li><a href="../../#user-file_init-and-final">user_finalize_modules</a>: For finalizing, e.g freeing variables and terminating processes</li>
<li><a href="../../#user-file_user-check">user_check</a>: Executed at the end of every time step, for e.g. computing and/or outputting user defined quantities.</li>
<li><a href="../../#user-file_mat-prop">material_properties</a>: For computing and setting material properties such as <code>rho</code>, <code>mu</code>, <code>cp</code> and <code>lambda</code>.</li>
<li><a href="../../#user-file_user-mesh-setup">user_mesh_setup</a>: For applying a deformation to the mesh element nodes, before the simulation time loop.</li>
<li><a href="../../#user-file_scalar-bc">scalar_user_bc</a>: For applying boundary conditions to the scalar, on all zones that are not already specified with uniform dirichlet values e.g. <code>d=1</code>. For more information on the scalar, see the <a href="../../#case-file_scalar">relevant section of the case file</a>.</li>
</ul>
<h2><a class="anchor" id="user-file_init-and-final"></a>
Initializing and finalizing</h2>
<p>The two subroutines <code>user_init_modules</code> and <code>user_finalize_modules</code> may be used to initialize/finalize any user defined variables, external objects, or processes. They are respectively executed right before/after the simulation time loop.</p>
<div class="fragment"><div class="line"><span class="comment">! Initialize user variables or external objects</span></div>
<div class="line"><span class="keyword">subroutine </span>initialize(t, u, v, w, p, coef, params)</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: t</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: v</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: w</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: p</div>
<div class="line">  <span class="keywordtype">type</span>(coef_t), <span class="keywordtype">intent(inout)</span> :: coef</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert your initialization code here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>initialize</div>
<div class="line"> </div>
<div class="line"><span class="comment">! Finalize user variables or external objects</span></div>
<div class="line"><span class="keyword">subroutine </span>finalize(t, params)</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: t</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert your code here</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>initialize</div>
</div><!-- fragment --><p>In the example above, the subroutines <code>initialize</code> and <code>finalize</code> contain the actual implementations. They must also be interfaced to the internal procedures <code>user_init_modules</code> and <code>user_finalize_modules</code> in <code>user_setup</code>:</p>
<div class="fragment"><div class="line"><span class="comment">! Register user defined functions (see user_intf.f90)</span></div>
<div class="line"><span class="keyword">subroutine </span>user_setup(u)</div>
<div class="line">  <span class="keywordtype">type</span>(user_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line"> </div>
<div class="line">  u%user_init_modules =&gt; initialize</div>
<div class="line">  u%user_finalize_modules =&gt; finalize</div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>user_setup</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>user_init_modules</code> and <code>user_finalize_modules</code> are independent of each other. Using one does not require the use of the other.</dd></dl>
<h2><a class="anchor" id="user-file_user-check"></a>
Computing at every time step</h2>
<p>The subroutine <code>user_check</code> is executed at the end of every time step. It can be used for computing and/or outputting your own variables/quantities at every time step. </p><div class="fragment"><div class="line"><span class="comment">! This is called at the end of every time step</span></div>
<div class="line"><span class="keyword">subroutine </span>usercheck(t, tstep, u, v, w, p, coef, param)</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: tstep</div>
<div class="line">  <span class="keywordtype">type</span>(coef_t), <span class="keywordtype">intent(inout)</span> :: coef</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: v</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: w</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: p</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: param</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! insert code below</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>usercheck</div>
</div><!-- fragment --><p>In the example above, the subroutine <code>usercheck</code> contains the actual implementation, and needs to be registered by adding:</p>
<div class="fragment"><div class="line">u%user_check =&gt; usercheck</div>
</div><!-- fragment --><p>to our <code>user_setup</code>.</p>
<h2><a class="anchor" id="user-file_mat-prop"></a>
Setting material properties</h2>
<p><code><a class="el" href="../../d8/d15/namespacematerial__properties.html" title="Implements material_properties_t type.">material_properties</a></code> allows for more complex computations and setting of various material properties, such as <code>rho</code>, <code>mu</code> for the fluid and <code>cp</code>, <code>lambda</code> for the scalar. The example below is taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/564686b127ff75a362a06126c6b23e9b4e21879e/examples/rayleigh-benard-cylinder/rayleigh.f90#L22C1-L38C41">rayleigh-benard-cylinder example</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>set_material_properties(t, tstep, rho, mu, cp, lambda, params)</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: tstep</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(inout)</span> :: rho, mu, cp, lambda</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: re</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">call </span>json_get(params, <span class="stringliteral">&quot;case.fluid.Ra&quot;</span>, ra)</div>
<div class="line">  <span class="keyword">call </span>json_get(params, <span class="stringliteral">&quot;case.scalar.Pr&quot;</span>, pr)</div>
<div class="line"> </div>
<div class="line">  re = sqrt(ra / pr)</div>
<div class="line">  mu = 1.0_rp / re</div>
<div class="line">  lambda = mu / pr</div>
<div class="line">  rho = 1.0_rp</div>
<div class="line">  cp = 1.0_rp</div>
<div class="line"><span class="keyword">end subroutine </span>set_material_properties</div>
</div><!-- fragment --><p>And of course not forgetting to register our function in <code>user_setup</code> by adding the following line:</p>
<div class="fragment"><div class="line">u%material_properties =&gt; set_material_properties</div>
</div><!-- fragment --><h2><a class="anchor" id="user-file_user-mesh-setup"></a>
Runtime mesh deformation</h2>
<p>This user function allows for the modification of the mesh at runtime, by acting on the element nodes of the mesh specified in the case file. This function is only called once before the simulation time loop. The example below is taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/a0613606360240e5059e65d6d98f4a57cf73e237/examples/tgv/tgv.f90#L27-L42">tgv example</a>.</p>
<div class="fragment"><div class="line"><span class="comment">! Rescale mesh</span></div>
<div class="line"><span class="keyword">subroutine </span>user_mesh_scale(msh)</div>
<div class="line">  <span class="keywordtype">type</span>(mesh_t), <span class="keywordtype">intent(inout)</span> :: msh</div>
<div class="line">  <span class="keywordtype">integer</span> :: i, p, nvert</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: d</div>
<div class="line">  d = 4._rp</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! original mesh has size 0..8 to be mapped onto -pi..pi</span></div>
<div class="line">  <span class="comment">! will be updated later to a method giving back the vertices of the mesh</span></div>
<div class="line">  nvert = <span class="keyword">size</span>(msh%points)</div>
<div class="line">  <span class="keywordflow">do</span> i = 1, nvert</div>
<div class="line">     msh%points(i)%x(1) = (msh%points(i)%x(1) - d) / d * pi</div>
<div class="line">     msh%points(i)%x(2) = (msh%points(i)%x(2) - d) / d * pi</div>
<div class="line">     msh%points(i)%x(3) = (msh%points(i)%x(3) - d) / d * pi</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>user_mesh_scale</div>
</div><!-- fragment --><p>The registering of the above function in <code>user_setup</code> should then be done as follows:</p>
<div class="fragment"><div class="line">u%user_mesh_setup =&gt; user_mesh_scale</div>
</div><!-- fragment --><h2><a class="anchor" id="user-file_scalar-bc"></a>
Scalar boundary conditions</h2>
<p>This user function can be used to specify the scalar boundary values, on all zones that are not already set to uniform Dirichlet or Neumann values e.g. <code>d=1</code> or <code>n=0</code>. For more information on the scalar, see the <a href="../../#case-file_scalar">relevant section of the case file</a>. The example below sets the scalar boundary condition values to be a linear function of the <code>z</code> coordinate (taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/aa72ad9bf34cbfbac0ee893c045639fdd095f80a/examples/rayleigh-benard-cylinder/rayleigh.f90#L41-L63">rayleigh-benard example</a>).</p>
<div class="fragment"><div class="line"><span class="keyword">subroutine </span>set_scalar_boundary_conditions(s, x, y, z, nx, ny, nz, ix, iy, iz, ie, t, tstep)</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(inout)</span> :: s</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: x</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: y</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: z</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: nx</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: ny</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: nz</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ix</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: iy</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: iz</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ie</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line">  <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: tstep</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! This will be used on all zones without labels</span></div>
<div class="line">  s = 1.0_rp - z</div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>set_scalar_boundary_conditions</div>
</div><!-- fragment --><p>This function will be called on all the points on the relevant boundaries. The registering of the above function in <code>user_setup</code> should be done as follows:</p>
<div class="fragment"><div class="line">u%scalar_user_bc =&gt; set_scalar_boundary_conditions</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md22"></a>
Case-specific user functions</h1>
<p>As explained in the <a class="el" href="../../dd/d33/case-file.html#md_pages_case_file">case file</a> page, certain components of the simulation can be set to be user defined. These components and their associated user functions are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">User function   </th><th class="markdownTableHeadNone">JSON Object in the case file    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fluid initial condition   </td><td class="markdownTableBodyNone"><a href="../../#user-file_user-ic">fluid_user_ic</a>   </td><td class="markdownTableBodyNone"><code>case.fluid.initial_condition</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scalar initial condition   </td><td class="markdownTableBodyNone"><a href="../../#user-file_user-ic">scalar_user_ic</a>   </td><td class="markdownTableBodyNone"><code>case.scalar.initial_condition</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fluid inflow boundary condition   </td><td class="markdownTableBodyNone"><a href="../../#user-file_fluid-user-if">fluid_user_if</a>   </td><td class="markdownTableBodyNone"><code>case.fluid.inflow_condition</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scalar boundary conditions   </td><td class="markdownTableBodyNone"><a href="../../#user-file_scalar-bc">scalar_user_bc</a>   </td><td class="markdownTableBodyNone">(user function is always called)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Fluid source term   </td><td class="markdownTableBodyNone"><a href="../../#user-file_user-f">fluid_user_f_vector or fluid_user_f</a>   </td><td class="markdownTableBodyNone"><code>case.fluid.source_terms</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Scalar source term   </td><td class="markdownTableBodyNone"><a href="../../#user-file_user-f">scalar_user_f_vector or scalar_user_f</a>   </td><td class="markdownTableBodyNone"><code>case.scalar.source_terms</code>   </td></tr>
</table>
<p>Note that <code>scalar_user_bc</code> is included for completeness but is technically not case-specific.</p>
<h2><a class="anchor" id="user-file_user-ic"></a>
Fluid and Scalar initial conditions</h2>
<p>Enabling user defined initial conditions for the fluid and/or scalar is done by setting the <code>initial_condition.type</code> to <code>"user"</code> in the relevant sections of the case file, <code>case.fluid</code> and/or <code>case.scalar</code>.</p>
<div class="fragment"><div class="line">&quot;case&quot;: {</div>
<div class="line">    &quot;fluid&quot;: {</div>
<div class="line">        &quot;initial_condition&quot;: {</div>
<div class="line">            &quot;type&quot;: &quot;user&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the relevant sections on the <a href="../../#case-file_fluid-ic">fluid</a> and <a href="../../#case-file_scalar">scalar</a> initial conditions in the <a href="../../#case-file">case file page</a> for more details.</p>
<p>The associated user functions for the fluid and/or scalar initial conditions can then be added to the user file. An example for the fluid taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/aa72ad9bf34cbfbac0ee893c045639fdd095f80a/examples/advecting_cone/advecting_cone.f90#L48-L75">advecting cone example</a>, is shown below.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">subroutine </span>set_velocity(u, v, w, p, params)</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: v</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: w</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: p</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line">  <span class="keywordtype">integer</span> :: i, e, k, j</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: x, y</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> i = 1, u%dof%size()</div>
<div class="line">     x = u%dof%x(i,1,1,1)</div>
<div class="line">     y = u%dof%y(i,1,1,1)</div>
<div class="line"> </div>
<div class="line">     <span class="comment">! Angular velocity is pi, giving a full rotation in 2 sec</span></div>
<div class="line">     u%x(i,1,1,1) = -y*pi</div>
<div class="line">     v%x(i,1,1,1) = x*pi</div>
<div class="line">     w%x(i,1,1,1) = 0</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_memcpy(u%x, u%x_d, u%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line">     <span class="keyword">call </span>device_memcpy(v%x, v%x_d, v%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line">     <span class="keyword">call </span>device_memcpy(w%x, w%x_d, w%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>set_velocity</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Notice the use of the <code>NEKO_BCKND_DEVICE</code> flag, which will be set to 1 if running on GPUs, and the calls to <code>device_memcpy</code> to transfer data between the host and the device. See <a href="../../#user-file_tips_running-on-gpus">Running on GPUs</a> for more information on how this works.</dd></dl>
<p>The same can be done for the scalar, with the example below also inspired from the <a href="https://github.com/ExtremeFLOW/neko/blob/aa72ad9bf34cbfbac0ee893c045639fdd095f80a/examples/advecting_cone/advecting_cone.f90#L14-L45">advecting cone example</a>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">subroutine </span>set_s_ic(s, params)</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: s</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line">  <span class="keywordtype">integer</span> :: i, e, k, j</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: cone_radius, mux, muy, x, y, r, theta</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Center of the cone</span></div>
<div class="line">  mux = 1</div>
<div class="line">  muy = 0</div>
<div class="line"> </div>
<div class="line">  cone_radius = 0.5</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> i = 1, s%dof%size()</div>
<div class="line">     x = s%dof%x(i,1,1,1) - mux</div>
<div class="line">     y = s%dof%y(i,1,1,1) - muy</div>
<div class="line"> </div>
<div class="line">     r = sqrt(x**2 + y**2)</div>
<div class="line">     theta = atan2(y, x)</div>
<div class="line"> </div>
<div class="line">     <span class="comment">! Check if the point is inside the cone&#39;s base</span></div>
<div class="line">     <span class="keywordflow">if</span> (r &gt; cone_radius) <span class="keywordflow">then</span></div>
<div class="line">       s%x(i,1,1,1) = 0.0</div>
<div class="line">     <span class="keywordflow">else</span></div>
<div class="line">       s%x(i,1,1,1) = 1.0 - r / cone_radius</div>
<div class="line"><span class="keywordflow">     endif</span></div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_memcpy(s%x, s%x_d, s%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>set_s_ic</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Notice the use of the <code>NEKO_BCKND_DEVICE</code> flag, which will be set to 1 if running on GPUs, and the calls to <code>device_memcpy</code> to transfer data between the host and the device. See <a href="../../#user-file_tips_running-on-gpus">Running on GPUs</a> for more information on how this works.</dd></dl>
<p>We should also add of the following lines in <code>user_setup</code>, registering our user functions <code>set_velocity</code> and <code>set_s_ic</code> to be used as the fluid and scalar initial conditions:</p>
<div class="fragment"><div class="line">u%fluid_user_ic =&gt; set_velocity</div>
<div class="line">u%scalar_user_ic =&gt; set_s_ic</div>
</div><!-- fragment --><h2><a class="anchor" id="user-file_fluid-user-if"></a>
Fluid inflow condition</h2>
<p>Enabling user defined inflow condition for the fluid is done by setting the <code>case.fluid.inflow_condition.type</code> to <code>"user"</code>:</p>
<div class="fragment"><div class="line">&quot;case&quot;: {</div>
<div class="line">    &quot;fluid&quot;: {</div>
<div class="line">        &quot;inflow_condition&quot;: {</div>
<div class="line">            &quot;type&quot;: &quot;user&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the <a href="../../#case-file_fluid-if">the relevant section</a> in the <a href="../../#case-file">case file page</a> for more details. The associated user function for the fluid inflow condition can then be added to the user file. An example inspired from the <a href="https://github.com/ExtremeFLOW/neko/blob/aa72ad9bf34cbfbac0ee893c045639fdd095f80a/examples/lid/lid.f90#L29-L53">lid-driven cavity example</a> is shown below.</p>
<div class="fragment"><div class="line"><span class="comment">! user-defined boundary condition</span></div>
<div class="line"> <span class="keyword">subroutine </span>user_bc(u, v, w, x, y, z, nx, ny, nz, ix, iy, iz, ie, t, tstep)</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(inout)</span> :: v</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(inout)</span> :: w</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: x</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: y</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: z</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: nx</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: ny</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: nz</div>
<div class="line">   <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ix</div>
<div class="line">   <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: iy</div>
<div class="line">   <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: iz</div>
<div class="line">   <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: ie</div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line">   <span class="keywordtype">integer</span>, <span class="keywordtype">intent(in)</span> :: tstep</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">   real</span>(kind=rp) lsmoothing</div>
<div class="line">   lsmoothing = 0.05_rp    <span class="comment">! length scale of smoothing at the edges</span></div>
<div class="line"> </div>
<div class="line">   u = step( x/lsmoothing ) * step( (1._rp-x)/lsmoothing )</div>
<div class="line">   v = 0._rp</div>
<div class="line">   w = 0._rp</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">end subroutine </span>user_bc</div>
</div><!-- fragment --><p>We should also add of the following line in <code>user_setup</code>, registering our user function <code>user_bc</code> to be used as the fluid inflow conditions:</p>
<div class="fragment"><div class="line">u%fluid_user_if =&gt; user_bc</div>
</div><!-- fragment --><h2><a class="anchor" id="user-file_user-f"></a>
Fluid and scalar source terms</h2>
<p>Enabling user defined source terms for the fluid and/or scalar is done by adding JSON Objects to the <code>case.fluid.source_terms</code> and/or <code>case.scalar.source_terms</code> lists.</p>
<div class="fragment"><div class="line">&quot;case&quot;: {</div>
<div class="line">    &quot;fluid&quot;: {</div>
<div class="line">        &quot;source_terms&quot;:</div>
<div class="line">        [</div>
<div class="line">            {</div>
<div class="line">                &quot;type&quot;: &quot;user_vector&quot;</div>
<div class="line">            }</div>
<div class="line">        ]</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>See the relevant sections on the <a href="../../#case-file_fluid-source-term">fluid</a> and <a href="../../#case-file_scalar">scalar</a> source terms in the <a href="../../#case-file">case file page</a> for more details.</p>
<dl class="section attention"><dt>Attention</dt><dd>There are two variants of the source term user functions: <code>_user_f</code> and <code>_user_f_vector</code>. The former is called when setting <code>"user_pointwise"</code> as the source term type, while the latter requires the use of the <code>"user_vector"</code> keyword in the case file. The pointwise variant, <code>fluid_user_f</code> is not supported on GPUs. In general, <code>fluid_user_f_vector</code> is the prefered variant, and is the one which will be use in our examples below. The same applies for the scalar source term user functions.</dd></dl>
<p>The associated user functions for the fluid and/or scalar source terms can then be added to the user file. An example for the fluid, taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/rayleigh-benard-cylinder/rayleigh.f90#L101C1-L121C44">rayleigh-benard-cylinder example</a>, is shown below.</p>
<div class="fragment"><div class="line"><span class="comment">! Sets the z-component of the fluid forcing term = scalar</span></div>
<div class="line"><span class="keyword">subroutine </span>set_bousinesq_forcing_term(f, t)</div>
<div class="line">  <span class="keywordtype">class</span>(fluid_user_source_term_t), <span class="keywordtype">intent(inout)</span> :: f</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line"> </div>
<div class="line">  <span class="comment">! Retrieve u,v,w,s fields from the field registry</span></div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">pointer</span> :: u, v, w, s</div>
<div class="line">  u =&gt; neko_field_registry%get_field(<span class="stringliteral">&#39;u&#39;</span>)</div>
<div class="line">  v =&gt; neko_field_registry%get_field(<span class="stringliteral">&#39;v&#39;</span>)</div>
<div class="line">  w =&gt; neko_field_registry%get_field(<span class="stringliteral">&#39;w&#39;</span>)</div>
<div class="line">  s =&gt; neko_field_registry%get_field(<span class="stringliteral">&#39;s&#39;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_rzero(f%u_d,f%dm%size())</div>
<div class="line">     <span class="keyword">call </span>device_rzero(f%v_d,f%dm%size())</div>
<div class="line">     <span class="keyword">call </span>device_copy(f%w_d,s%x_d,f%dm%size())</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">     <span class="keyword">call </span>rzero(f%u,f%dm%size())</div>
<div class="line">     <span class="keyword">call </span>rzero(f%v,f%dm%size())</div>
<div class="line">     <span class="keyword">call </span>copy(f%w,s%x,f%dm%size())</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"><span class="keyword">end subroutine </span>set_bousinesq_forcing_term</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Notice the use of the <code>neko_field_registry</code> to retrieve the velocity and scalar fields. See <a href="../../#user-file_tips_registries">Registries</a> for more information about registries in neko. </dd>
<dd>
Notice the use of the <code>NEKO_BCKND_DEVICE</code> flag, which will be set to 1 if running on GPUs, and the use of <code>device_</code> functions. See <a href="../../#user-file_tips_running-on-gpus">Running on GPUs</a> for more information on how this works.</dd></dl>
<p>The same can be done for the scalar, with the example below also taken from the <a href="https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/scalar_mms/scalar_mms.f90#L28-L47">scalar_mms example</a>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">subroutine </span>set_source(f, t)</div>
<div class="line">  <span class="keywordtype">class</span>(scalar_user_source_term_t), <span class="keywordtype">intent(inout)</span> :: f</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp), <span class="keywordtype">intent(in)</span> :: t</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: x, y</div>
<div class="line">  <span class="keywordtype">integer</span> :: i</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> i = 1, f%dm%size()</div>
<div class="line">     x = f%dm%x(i,1,1,1)</div>
<div class="line">     y = f%dm%y(i,1,1,1)</div>
<div class="line"> </div>
<div class="line">     <span class="comment">! 0.01 is the viscosity</span></div>
<div class="line">     f%s(i,1,1,1) = cos(x) - 0.01 * sin(x) - 1.0_rp</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_memcpy(f%s, f%s_d, f%dm%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>set_source</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Notice the use of the <code>NEKO_BCKND_DEVICE</code> flag, which will be set to 1 if running on GPUs, and the call to <code>device_memcpy</code> to transfer data between the host and the device. See <a href="../../#user-file_tips_running-on-gpus">Running on GPUs</a> for more information on how this works.</dd></dl>
<p>We should also add of the following lines in <code>user_setup</code>, registering our user functions <code>set_boussinesq_forcing_term</code> and <code>set_source</code> to be used as the fluid and scalar source terms:</p>
<div class="fragment"><div class="line">u%fluid_user_f_vector =&gt; set_boussinesq_forcing_term</div>
<div class="line">u%scalar_user_f_vector =&gt; set_source</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Additional remarks and tips</h1>
<h2><a class="anchor" id="user-file_tips_running-on-gpus"></a>
Running on GPUs</h2>
<p>When running on GPUs, special care must be taken when using certain user functions. The short explanation is that the device (GPU) has its own memory and cannot directly access the memory on the host (CPU). This means that data and more specifically arrays must be copied manually from the host to the device (see <a href="https://neko.cfd/docs/d6/dac/interfacedevice_1_1device__memcpy.html">device_memcpy</a>).</p>
<dl class="section attention"><dt>Attention</dt><dd>In some cases, data transfer via <code>device_memcpy</code> is avoidable. Neko has some device math functions implemented that operate directly on device arrays. If you can decompose whatever operations you are performing in a user function into a set of instructions from the <code>math</code> module (e.g. <code>cadd</code>, <code>cfill</code>, <code>sub2</code>, ...), you may use the corresponding <code><a class="el" href="../../d2/d73/namespacedevice__math.html">device_math</a></code> functions to <a href="../../#accelerators_offload-work">offload work to the GPU</a>. See the <a href="../../#user-file_user-f">fluid forcing code snippet</a> for a simple example. For more advanced examples, see the <a href="https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/rayleigh-benard/rayleigh.f90#L96-119">rayleigh-benard example</a> or the <a href="https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/tgv/tgv.f90#L146-172">tgv example</a>.</dd></dl>
<p>To illustrate this, let us have a look at the <a href="../../#user-file_user-ic">fluid initial condition code snippet</a>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">subroutine </span>set_velocity(u, v, w, p, params)</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: u</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: v</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: w</div>
<div class="line">  <span class="keywordtype">type</span>(field_t), <span class="keywordtype">intent(inout)</span> :: p</div>
<div class="line">  <span class="keywordtype">type</span>(json_file), <span class="keywordtype">intent(inout)</span> :: params</div>
<div class="line">  <span class="keywordtype">integer</span> :: i, e, k, j</div>
<div class="line"><span class="keywordtype">  real</span>(kind=rp) :: x, y</div>
<div class="line"> </div>
<div class="line">  <span class="comment">!</span></div>
<div class="line">  <span class="comment">! 1. Set the initial condition in fields u%x, v%x, w%x</span></div>
<div class="line">  <span class="comment">!</span></div>
<div class="line">  <span class="keywordflow">do</span> i = 1, u%dof%size()</div>
<div class="line">     x = u%dof%x(i,1,1,1)</div>
<div class="line">     y = u%dof%y(i,1,1,1)</div>
<div class="line"> </div>
<div class="line">     <span class="comment">! Angular velocity is pi, giving a full rotation in 2 sec</span></div>
<div class="line">     u%x(i,1,1,1) = -y*pi</div>
<div class="line">     v%x(i,1,1,1) = x*pi</div>
<div class="line">     w%x(i,1,1,1) = 0</div>
<div class="line"><span class="keywordflow">  end do</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">!</span></div>
<div class="line">  <span class="comment">! 2. Copy the data set in u%x, v%x, w%x to the device arrays</span></div>
<div class="line">  <span class="comment">! u%x_d, v%x_d, w%x_d.</span></div>
<div class="line">  <span class="comment">!</span></div>
<div class="line">  <span class="keywordflow">if</span> (neko_bcknd_device .eq. 1) <span class="keywordflow">then</span></div>
<div class="line">     <span class="keyword">call </span>device_memcpy(u%x, u%x_d, u%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line">     <span class="keyword">call </span>device_memcpy(v%x, v%x_d, v%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line">     <span class="keyword">call </span>device_memcpy(w%x, w%x_d, w%dof%size(), &amp;</div>
<div class="line">                        host_to_device, sync=.false.)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">end subroutine </span>set_velocity</div>
</div><!-- fragment --><p>The code above is used to set the fluid initial condition, by specifying the values of fields <code>u,v,w</code> (and <code>p</code>) at all points in the domain. Notice that we have divided the above code into two parts.</p>
<p>In the first part, we set the velocity components <code>u=-y*pi*</code>, <code>v=x*pi*</code>, and <code>w=0</code>, which updates the velocity field arrays <code>u%x, v%x, w%x</code> allocated on the <b>host (CPU)</b>. If we were to run on GPUs, these lines of code would only act on the velocity arrays on the host (CPU), leaving the device (GPU) arrays untouched.</p>
<p>We take care of this in the second part, for all three velocity arrays. To update the device (GPU) arrays, we use <code>device_memcpy</code> to copy the data contained in a host (CPU) array to a device (GPU) array. Looking at the details of the <code>device_memcpy</code> calls, we note the following:</p><ul>
<li>Device arrays are refered to by appending the suffix <code>_d</code> to the host array variable name (e.g. <code>u%x</code> and <code>u%x_d</code>). This is the standard in Neko.</li>
<li>We specify the direction of the data movement with the flag <code>HOST_TO_DEVICE</code>. Other flags can also be used to move data from device to host (<code>DEVICE_TO_HOST</code>) or device to device (<code>DEVICE_TO_DEVICE</code>). See the <a href="../../#accelerators_data-transfer">accelerators page</a> for more details on this.</li>
<li>The <code>sync</code> argument is a non-optional argument which dictates wether or not to perform the data transfer synchronously.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Use asynchronous data transfers at your own risk! If you are unsure, use <code>sync = .true.</code> as a starting point.</dd></dl>
<p>Finally, observe that we use the flag <code>NEKO_BCKND_DEVICE</code> to check if we are indeed running on GPUs. In that case, <code>NEKO_BCKND_DEVICE</code> would be equal to 1.</p>
<h2><a class="anchor" id="user-file_tips_registries"></a>
Registries</h2>
<p>Neko uses the concept of <code>registry</code> as a practical way to retrieve fields and point zones anywhere in the user file.</p>
<p>The field registry <code>neko_field_registry</code> is often used in user functions where certain fields are not directly accessible as arguments. One can retrieve any field in the registry by its <code>name</code> with <code>neko_field_registry%get_field(name)</code>. Default fields that are added to the registry are <code>u,v,w,p</code> and <code>s</code> if running with the scalar enabled. For a practical example of usage, see the [rayleigh benard example](<a href="https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/rayleigh-benard/rayleigh.f90#L102-L105">https://github.com/ExtremeFLOW/neko/blob/49925b7a04a638259db3b1ddd54349ca57f5d207/examples/rayleigh-benard/rayleigh.f90#L102-L105</a>)</p>
<p>Other fields may be added to the registry by various simulation components. For example:</p><ul>
<li>If running with <code>simulation_components.vorticity</code> enabled, the fields <code>omega_x, omega_y, omega_z</code> will be accessible in the registry.</li>
<li>If running with <code>simulation_components.lambda2</code> enabled, the field <code><a class="el" href="../../d0/d66/namespacelambda2.html" title="A simulation component that computes lambda2 The values are stored in the field registry under the na...">lambda2</a></code> will be accessible in the registry.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>You can add your own fields to the registry with <a href="https://neko.cfd/docs/d1/dc4/namespacefield__registry.html#a10e4570d0cae94f110c9b0eacbb56769">neko_field_registry%add_field</a>.</dd></dl>
<p>The point zone registry, <code>neko_point_zone_registry</code>, can be used to retrieve pointers to <code>point_zone_t</code> objects defined in the case file. See <a href="../../#point-zones_using-point-zones">using point zones</a> for detailed instructions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">Neko Manual</a></li>
    <li class="footer">Generated on Wed Mar 27 2024 03:38:47 for Neko by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
